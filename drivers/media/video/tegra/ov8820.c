/* 2012-07-20: File changed by Sony Corporation */
/*
 * ov8820.c - ov8820 sensor driver
 *
 * Copyright (C) 2011 Google Inc.
 *
 * This file is licensed under the terms of the GNU General Public License
 * version 2. This program is licensed "as is" without any warranty of any
 * kind, whether express or implied.
 */

#include <linux/delay.h>
#include <linux/fs.h>
#include <linux/i2c.h>
#include <linux/platform_device.h>
#include <linux/miscdevice.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <media/ov8820-i2c.h>
#include <media/ov8820.h>
#include <media/tegra_camera.h>

struct ov8820_reg {
	u16 addr;
	u16 val;
};

struct ov8820_info {
	int mode;
	struct i2c_client *i2c_client;
	struct ov8820_platform_data *pdata;
};

static struct ov8820_info *info;

static u8 FuseID[5];
static u8 FuseIDReadOnce = 0;

#define OV8820_TABLE_WAIT_MS 0
#define OV8820_TABLE_END 1
#define OV8820_MAX_RETRIES 3

static struct ov8820_reg tp_none_seq[] = {
    {0x501F, 0x20},
    //{0x5001, 0x00},
    {OV8820_TABLE_END, 0x0000}
};

static struct ov8820_reg tp_cbars_seq[] = {
    {0x0601, 0x80}, //[7] color bar enable
    {0x501F, 0x00},
    {OV8820_TABLE_END, 0x0000}
};

static struct ov8820_reg *test_pattern_modes[] = {
    tp_none_seq,
    tp_cbars_seq,
};

static struct ov8820_reg reset_seq[] = {
	{0x0103, 0x01}, /* reset registers pg 72 */
	{OV8820_TABLE_WAIT_MS, 5},
	{0x0103, 0x00}, /* register power down pg 72 */
	{OV8820_TABLE_WAIT_MS, 5},
	{OV8820_TABLE_END, 0x0000},
};

static struct ov8820_reg mode_3264x2448[] =
{
	{0x3000, 0x02},
	{0x3001, 0x00},
	{0x3002, 0x6c}, /* 8bit sccb_id */
	{0x3003, 0xce},
	{0x3004, 0xd8},
	{0x3005, 0x00},
	{0x3006, 0x10},
	{0x3007, 0x3b},
	{0x300d, 0x00},
	{0x301f, 0x09},
	{0x3010, 0x00},
	{0x3011, 0x01},
	{0x3012, 0x80},
	{0x3013, 0x39},
	{0x3018, 0x00},
	{0x3104, 0x20},
	{0x3300, 0x00},
	{0x3500, 0x00},
	{0x3501, 0x09},
	{0x3502, 0xae},
	{0x3503, 0x07}, /* AGC[1]/AEC[0] Manual Enable */
	{0x3509, 0x00}, /* gain stuff - 350[a/b]|[4/5] */
	{0x350b, 0x7f},
	{0x3600, 0x08},
	{0x3601, 0x44},
	{0x3602, 0x75},
	{0x3603, 0x5c},
	{0x3604, 0x98},
	{0x3605, 0xe9},
	{0x3609, 0xb8},
	{0x360a, 0xbc},
	{0x360b, 0xb4},
	{0x360c, 0x0d},
	{0x3613, 0x02},
	{0x3614, 0x0f},
	{0x3615, 0x00},
	{0x3616, 0x03},
	{0x3617, 0x01},
	{0x361a, 0xb0},
	{0x361b, 0x04},
	{0x361c, 0x06},
	{0x3700, 0x20},
	{0x3701, 0x44},
	{0x3702, 0x50},
	{0x3703, 0xcc},
	{0x3704, 0x19},
	{0x3706, 0x4b},
	{0x3707, 0x63},
	{0x3708, 0x84},
	{0x3709, 0x40},
	{0x370a, 0x12},
	{0x370b, 0x01},
	{0x370c, 0x50},
	{0x370d, 0x0c},
	{0x370e, 0x00},
	{0x3711, 0x01},
	{0x3712, 0x9c},
	{0x3800, 0x00},
	{0x3801, 0x00},
	{0x3802, 0x00},
	{0x3803, 0x00},
	{0x3804, 0x0c},
	{0x3805, 0xdf},
	{0x3806, 0x09},
	{0x3807, 0x9b},
	{0x3808, 0x0c},
	{0x3809, 0xc0},
	{0x380a, 0x09},
	{0x380b, 0x90},
	{0x380c, 0x0d},
	{0x380d, 0x80},
	{0x380e, 0x09},
	{0x380f, 0xb4},
	{0x3810, 0x00},
	{0x3811, 0x10},
	{0x3812, 0x00},
	{0x3813, 0x06},
	{0x3814, 0x11},
	{0x3815, 0x11},
	{0x3816, 0x02},
	{0x3817, 0x40},
	{0x3818, 0x00},
	{0x3819, 0x40},
	{0x3820, 0x00},
	{0x3821, 0x16},
	{0x3d00, 0x00},
	{0x3d01, 0x00},
	{0x3d02, 0x00},
	{0x3d03, 0x00},
	{0x3d04, 0x00},
	{0x3d05, 0x00},
	{0x3d06, 0x00},
	{0x3d07, 0x00},
	{0x3d08, 0x00},
	{0x3d09, 0x00},
	{0x3d0a, 0x00},
	{0x3d0b, 0x00},
	{0x3d0c, 0x00},
	{0x3d0d, 0x00},
	{0x3d0e, 0x00},
	{0x3d0f, 0x00},
	{0x3d10, 0x00},
	{0x3d11, 0x00},
	{0x3d12, 0x00},
	{0x3d13, 0x00},
	{0x3d14, 0x00},
	{0x3d15, 0x00},
	{0x3d16, 0x00},
	{0x3d17, 0x00},
	{0x3d18, 0x00},
	{0x3d19, 0x00},
	{0x3d1a, 0x00},
	{0x3d1b, 0x00},
	{0x3d1c, 0x00},
	{0x3d1d, 0x00},
	{0x3d1e, 0x00},
	{0x3d1f, 0x00},
	{0x3d80, 0x00},
	{0x3d81, 0x00},
	{0x3d84, 0x00},
	{0x3f00, 0x02},
	{0x3f01, 0xfc},
	{0x3f05, 0x10},
	{0x3f06, 0x00},
	{0x3f07, 0x00},
	{0x4000, 0x29},
	{0x4001, 0x02},
	{0x4002, 0x45},
	{0x4003, 0x08},
	{0x4004, 0x04},
	{0x4005, 0x18},
	{0x4300, 0xff},
	{0x4303, 0x00},
	{0x4304, 0x08},
	{0x4307, 0x00},
	{0x4600, 0x04},
	{0x4601, 0x00},
	{0x4602, 0x78},
	{0x4800, 0x04},
	{0x4801, 0x0f},
	{0x4837, 0x28},
	{0x4843, 0x02},
    {0x5000, 0x86},//Enable defect pixel correction
	{0x5001, 0x00}, /* MWB gain clock enable[0x01] disable[0x00]*/
	{0x5002, 0x00},
	{0x5068, 0x00},
	{0x506a, 0x00},
	{0x501f, 0x00},
	{0x3406, 0x00}, /* MWB GAIN06 (Digital) MWB gain enable */
	{0x5025, 0x00}, /* Investigate ISP CTRL 25 for MWB gain */
	{0x5c00, 0x80},
	{0x5c01, 0x00},
	{0x5c02, 0x00},
	{0x5c03, 0x00},
	{0x5c04, 0x00},
	{0x5c05, 0x00},
	{0x5c06, 0x00},
	{0x5c07, 0x80},
	{0x5c08, 0x10},
	{0x6700, 0x05},
	{0x6701, 0x19},
	{0x6702, 0xfd},
	{0x6703, 0xd1},
	{0x6704, 0xff},
	{0x6705, 0xff},
	{0x6800, 0x10},
	{0x6801, 0x02},
	{0x6802, 0x90},
	{0x6803, 0x10},
	{0x6804, 0x59},
	{0x6900, 0x61},
    {0x6901, 0x05},
	{0x3612, 0x00},
	{0x3617, 0xa1},
	{0x3b1f, 0x00},
	{0x3000, 0x12},
	{0x3000, 0x16},
	{0x3b1f, 0x00},
	{0x5800, 0x16},
	{0x5801, 0x0b},
	{0x5802, 0x09},
	{0x5803, 0x09},
	{0x5804, 0x0b},
	{0x5805, 0x15},
	{0x5806, 0x07},
	{0x5807, 0x05},
	{0x5808, 0x03},
	{0x5809, 0x03},
	{0x580a, 0x05},
	{0x580b, 0x06},
	{0x580c, 0x05},
	{0x580d, 0x02},
	{0x580e, 0x00},
	{0x580f, 0x00},
	{0x5810, 0x02},
	{0x5811, 0x05},
	{0x5812, 0x06},
	{0x5813, 0x02},
	{0x5814, 0x00},
	{0x5815, 0x00},
	{0x5816, 0x02},
	{0x5817, 0x05},
	{0x5818, 0x07},
	{0x5819, 0x05},
	{0x581a, 0x04},
	{0x581b, 0x03},
	{0x581c, 0x05},
	{0x581d, 0x06},
	{0x581e, 0x13},
	{0x581f, 0x0b},
	{0x5820, 0x09},
	{0x5821, 0x09},
	{0x5822, 0x0b},
	{0x5823, 0x16},
	{0x5824, 0x63},
	{0x5825, 0x23},
	{0x5826, 0x25},
	{0x5827, 0x23},
	{0x5828, 0x45},
	{0x5829, 0x23},
	{0x582a, 0x21},
	{0x582b, 0x41},
	{0x582c, 0x41},
	{0x582d, 0x05},
	{0x582e, 0x23},
	{0x582f, 0x41},
	{0x5830, 0x41},
	{0x5831, 0x41},
	{0x5832, 0x03},
	{0x5833, 0x25},
	{0x5834, 0x23},
	{0x5835, 0x21},
	{0x5836, 0x23},
	{0x5837, 0x05},
	{0x5838, 0x25},
	{0x5839, 0x43},
	{0x583a, 0x25},
	{0x583b, 0x23},
	{0x583c, 0x65},
	{0x583d, 0xcf},
	{0x5842, 0x00},
	{0x5843, 0xef},
	{0x5844, 0x01},
	{0x5845, 0x3f},
	{0x5846, 0x01},
	{0x5847, 0x3f},
	{0x5848, 0x00},
	{0x5849, 0xd5},
	{0x0100, 0x01},

	{OV8820_TABLE_END, 0x0000}
};

static struct ov8820_reg mode_1632x1224[] =
{
    {0x3000, 0x02},
    {0x3001, 0x00},
    {0x3002, 0x6c},
    {0x3003, 0xce},
    {0x3004, 0xd9},
    {0x3005, 0x00},
    {0x3006, 0x10},
    {0x3007, 0x3b},
    {0x300d, 0x00},
    {0x301f, 0x09},
    {0x3010, 0x00},
    {0x3011, 0x01},
    {0x3012, 0x80},
    {0x3013, 0x39},
    {0x3018, 0x00},
    {0x3104, 0x20},
    {0x3300, 0x00},
    {0x3500, 0x00},
    {0x3501, 0x4e},
    {0x3502, 0xa0},
    {0x3503, 0x07},
    {0x3509, 0x00},
    {0x350b, 0x1f},
    {0x3600, 0x05},
    {0x3601, 0x32},
    {0x3602, 0x44},
    {0x3603, 0x5c},
    {0x3604, 0x98},
    {0x3605, 0xe9},
    {0x3609, 0xb8},
    {0x360a, 0xbc},
    {0x360b, 0xb4},
    {0x360c, 0x0d},
    {0x3613, 0x02},
    {0x3614, 0x0f},
    {0x3615, 0x00},
    {0x3616, 0x03},
    {0x3617, 0x01},
    {0x361a, 0xb0},
    {0x361b, 0x04},
    {0x361c, 0x06},
    {0x3700, 0x20},
    {0x3701, 0x44},
    {0x3702, 0x70},
    {0x3703, 0x4f},
    {0x3704, 0x69},
    {0x3706, 0x7b},
    {0x3707, 0x63},
    {0x3708, 0x85},
    {0x3709, 0x40},
    {0x370a, 0x12},
    {0x370b, 0x01},
    {0x370c, 0x50},
    {0x370d, 0x0c},
    {0x370e, 0x08},
    {0x3711, 0x01},
    {0x3712, 0xcc},
    {0x3800, 0x00},
    {0x3801, 0x00},
    {0x3802, 0x00},
    {0x3803, 0x00},
    {0x3804, 0x0c},
    {0x3805, 0xdf},
    {0x3806, 0x09},
    {0x3807, 0x9b},
    {0x3808, 0x06},
    {0x3809, 0x60},
    {0x380a, 0x04},
    {0x380b, 0xc8},
    {0x380c, 0x0d},
    {0x380d, 0xbc},
    {0x380e, 0x04},
    {0x380f, 0xf0},
    {0x3810, 0x00},
    {0x3811, 0x08},
    {0x3812, 0x00},
    {0x3813, 0x04},
    {0x3814, 0x31},
    {0x3815, 0x31},
    {0x3816, 0x02},
    {0x3817, 0x40},
    {0x3818, 0x00},
    {0x3819, 0x40},
    {0x3820, 0x00},
    {0x3821, 0x17},
    {0x3d00, 0x00},
    {0x3d01, 0x00},
    {0x3d02, 0x00},
    {0x3d03, 0x00},
    {0x3d04, 0x00},
    {0x3d05, 0x00},
    {0x3d06, 0x00},
    {0x3d07, 0x00},
    {0x3d08, 0x00},
    {0x3d09, 0x00},
    {0x3d0a, 0x00},
    {0x3d0b, 0x00},
    {0x3d0c, 0x00},
    {0x3d0d, 0x00},
    {0x3d0e, 0x00},
    {0x3d0f, 0x00},
    {0x3d10, 0x00},
    {0x3d11, 0x00},
    {0x3d12, 0x00},
    {0x3d13, 0x00},
    {0x3d14, 0x00},
    {0x3d15, 0x00},
    {0x3d16, 0x00},
    {0x3d17, 0x00},
    {0x3d18, 0x00},
    {0x3d19, 0x00},
    {0x3d1a, 0x00},
    {0x3d1b, 0x00},
    {0x3d1c, 0x00},
    {0x3d1d, 0x00},
    {0x3d1e, 0x00},
    {0x3d1f, 0x00},
    {0x3d80, 0x00},
    {0x3d81, 0x00},
    {0x3d84, 0x00},
    {0x3f00, 0x00},
    {0x3f01, 0xfc},
    {0x3f05, 0x10},
    {0x3f06, 0x00},
    {0x3f07, 0x00},
    {0x4000, 0x29},
    {0x4001, 0x02},
    {0x4002, 0x45},
    {0x4003, 0x08},
    {0x4004, 0x04},
    {0x4005, 0x18},
    {0x4300, 0xff},
    {0x4303, 0x00},
    {0x4304, 0x08},
    {0x4307, 0x00},
    {0x4600, 0x04},
    {0x4601, 0x00},
    {0x4602, 0x78},
    {0x4800, 0x04},
    {0x4801, 0x0f},
    {0x4837, 0x28},
    {0x4843, 0x02},
    {0x5000, 0x86},//Enable defect pixel correction
    {0x5001, 0x00},
    {0x5002, 0x00},
    {0x5068, 0x00},
    {0x506a, 0x00},
    {0x501f, 0x00},
    {0x5c00, 0x80},
    {0x5c01, 0x00},
    {0x5c02, 0x00},
    {0x5c03, 0x00},
    {0x5c04, 0x00},
    {0x5c05, 0x00},
    {0x5c06, 0x00},
    {0x5c07, 0x80},
    {0x5c08, 0x10},
    {0x6700, 0x05},
    {0x6701, 0x19},
    {0x6702, 0xfd},
    {0x6703, 0xd1},
    {0x6704, 0xff},
    {0x6705, 0xff},
    {0x6800, 0x10},
    {0x6801, 0x02},
    {0x6802, 0x90},
    {0x6803, 0x10},
    {0x6804, 0x59},
    {0x6900, 0x61},
    {0x6901, 0x05},
    {0x3612, 0x00},
    {0x3617, 0xa1},
    {0x3b1f, 0x00},
    {0x3000, 0x12},
    {0x3000, 0x16},
    {0x3b1f, 0x00},
    {0x5800, 0x16},
    {0x5801, 0x0b},
    {0x5802, 0x09},
    {0x5803, 0x09},
    {0x5804, 0x0b},
    {0x5805, 0x15},
    {0x5806, 0x07},
    {0x5807, 0x05},
    {0x5808, 0x03},
    {0x5809, 0x03},
    {0x580a, 0x05},
    {0x580b, 0x06},
    {0x580c, 0x05},
    {0x580d, 0x02},
    {0x580e, 0x00},
    {0x580f, 0x00},
    {0x5810, 0x02},
    {0x5811, 0x05},
    {0x5812, 0x06},
    {0x5813, 0x02},
    {0x5814, 0x00},
    {0x5815, 0x00},
    {0x5816, 0x02},
    {0x5817, 0x05},
    {0x5818, 0x07},
    {0x5819, 0x05},
    {0x581a, 0x04},
    {0x581b, 0x03},
    {0x581c, 0x05},
    {0x581d, 0x06},
    {0x581e, 0x13},
    {0x581f, 0x0b},
    {0x5820, 0x09},
    {0x5821, 0x09},
    {0x5822, 0x0b},
    {0x5823, 0x16},
    {0x5824, 0x63},
    {0x5825, 0x23},
    {0x5826, 0x25},
    {0x5827, 0x23},
    {0x5828, 0x45},
    {0x5829, 0x23},
    {0x582a, 0x21},
    {0x582b, 0x41},
    {0x582c, 0x41},
    {0x582d, 0x05},
    {0x582e, 0x23},
    {0x582f, 0x41},
    {0x5830, 0x41},
    {0x5831, 0x41},
    {0x5832, 0x03},
    {0x5833, 0x25},
    {0x5834, 0x23},
    {0x5835, 0x21},
    {0x5836, 0x23},
    {0x5837, 0x05},
    {0x5838, 0x25},
    {0x5839, 0x43},
    {0x583a, 0x25},
    {0x583b, 0x23},
    {0x583c, 0x65},
    {0x583d, 0xcf},
    {0x5842, 0x00},
    {0x5843, 0xef},
    {0x5844, 0x01},
    {0x5845, 0x3f},
    {0x5846, 0x01},
    {0x5847, 0x3f},
    {0x5848, 0x00},
    {0x5849, 0xd5},
    {0x0100, 0x01},

    {OV8820_TABLE_END, 0x0000}
};

static struct ov8820_reg mode_1920x1080[] =
{
    {0x3000, 0x02},
    {0x3001, 0x00},
    {0x3002, 0x6c},
    {0x3003, 0xce},
    {0x3004, 0xd4}, //;ce
    {0x3005, 0x00},
    {0x3006, 0x00},
    {0x3007, 0x3b},
    {0x300d, 0x00},
    {0x301f, 0x09},
    {0x3010, 0x00},
    {0x3011, 0x01}, //2-lane
    {0x3012, 0x80},
    {0x3013, 0x39},
    {0x3018, 0x00},
    {0x3104, 0x20},
    {0x3300, 0x00},
    {0x3500, 0x00},
    {0x3501, 0x74},
    {0x3502, 0x60},
    {0x3503, 0x07},
    {0x3509, 0x00},
    {0x350b, 0x1f},
    {0x3600, 0x08},
    {0x3601, 0x44},
    {0x3602, 0x75},
    {0x3603, 0x5c},
    {0x3604, 0x98},
    {0x3605, 0xe9},
    {0x3609, 0xb8},
    {0x360a, 0xbc},
    {0x360b, 0xb4},
    {0x360c, 0x0d},
    {0x3613, 0x02},
    {0x3614, 0x0f},
    {0x3615, 0x00},
    {0x3616, 0x03},
    {0x3617, 0x01},
    {0x361a, 0xb0},
    {0x361b, 0x04},
    {0x361c, 0x06},
    {0x3700, 0x20},
    {0x3701, 0x44},
    {0x3702, 0x50},
    {0x3703, 0xcc},
    {0x3704, 0x19},
    {0x3706, 0x4b},
    {0x3707, 0x63},
    {0x3708, 0x84},
    {0x3709, 0x40},
    {0x370a, 0x12},
    {0x370b, 0x01},
    {0x370c, 0x50},
    {0x370d, 0x0c},
    {0x370e, 0x00},
    {0x3711, 0x01},
    {0x3712, 0x9c},
    {0x3800, 0x00},
    {0x3801, 0x00},
    {0x3802, 0x01},
    {0x3803, 0x30},
    {0x3804, 0x0c},
    {0x3805, 0xdf},
    {0x3806, 0x08},
    {0x3807, 0x67},
    {0x3808, 0x07},
    {0x3809, 0x80},
    {0x380a, 0x04},
    {0x380b, 0x38},
    {0x380c, 0x0d},
    {0x380d, 0xf0},
    {0x380e, 0x07},
    {0x380f, 0x4c},
    {0x3810, 0x00},
    {0x3811, 0x10},
    {0x3812, 0x00},
    {0x3813, 0x06},
    {0x3814, 0x11},
    {0x3815, 0x11},
    {0x3816, 0x02},
    {0x3817, 0x40},
    {0x3818, 0x00},
    {0x3819, 0x40},
    {0x3820, 0x00},
    {0x3821, 0x16},
    {0x3d00, 0x00},
    {0x3d01, 0x00},
    {0x3d02, 0x00},
    {0x3d03, 0x00},
    {0x3d04, 0x00},
    {0x3d05, 0x00},
    {0x3d06, 0x00},
    {0x3d07, 0x00},
    {0x3d08, 0x00},
    {0x3d09, 0x00},
    {0x3d0a, 0x00},
    {0x3d0b, 0x00},
    {0x3d0c, 0x00},
    {0x3d0d, 0x00},
    {0x3d0e, 0x00},
    {0x3d0f, 0x00},
    {0x3d10, 0x00},
    {0x3d11, 0x00},
    {0x3d12, 0x00},
    {0x3d13, 0x00},
    {0x3d14, 0x00},
    {0x3d15, 0x00},
    {0x3d16, 0x00},
    {0x3d17, 0x00},
    {0x3d18, 0x00},
    {0x3d19, 0x00},
    {0x3d1a, 0x00},
    {0x3d1b, 0x00},
    {0x3d1c, 0x00},
    {0x3d1d, 0x00},
    {0x3d1e, 0x00},
    {0x3d1f, 0x00},
    {0x3d80, 0x00},
    {0x3d81, 0x00},
    {0x3d84, 0x00},
    {0x3f00, 0x02},
    {0x3f01, 0xfc},
    {0x3f05, 0x10},
    {0x3f06, 0x00},
    {0x3f07, 0x00},
    {0x4000, 0x29},
    {0x4001, 0x02},
    {0x4002, 0x45},
    {0x4003, 0x08},
    {0x4004, 0x04},
    {0x4005, 0x18},
    {0x4300, 0xff},
    {0x4303, 0x00},
    {0x4304, 0x08},
    {0x4307, 0x00},
    {0x4600, 0x04},
    {0x4601, 0x01},
    {0x4602, 0x00},
    {0x4800, 0x24}, //0x4800[5]=1 as noncontinuous clock
    {0x4801, 0x0f},
    {0x4837, 0x16}, //
    {0x4843, 0x02}, //0x4843[1]=1 as manually set pclk divider
    {0x5000, 0x86},//Enable defect pixel correction
    {0x5001, 0x00},
    {0x5002, 0x00},
    {0x5068, 0x53},
    {0x506a, 0x53},
    {0x501f, 0x00},
    {0x5c00, 0x80},
    {0x5c01, 0x00},
    {0x5c02, 0x00},
    {0x5c03, 0x00},
    {0x5c04, 0x00},
    {0x5c05, 0x00},
    {0x5c06, 0x00},
    {0x5c07, 0x80},
    {0x5c08, 0x10},
    {0x6700, 0x05},
    {0x6701, 0x19},
    {0x6702, 0xfd},
    {0x6703, 0xd1},
    {0x6704, 0xff},
    {0x6705, 0xff},
    {0x6800, 0x10},
    {0x6801, 0x02},
    {0x6802, 0x90},
    {0x6803, 0x10},
    {0x6804, 0x59},
    {0x6900, 0x61},
    {0x6901, 0x05},
    {0x3612, 0x00},
    {0x3617, 0xa1},
    {0x3b1f, 0x00},
    {0x3000, 0x12},
    {0x3000, 0x16},
    {0x3b1f, 0x00},
    {0x5800, 0x16},
    {0x5801, 0x0b},
    {0x5802, 0x09},
    {0x5803, 0x09},
    {0x5804, 0x0b},
    {0x5805, 0x15},
    {0x5806, 0x07},
    {0x5807, 0x05},
    {0x5808, 0x03},
    {0x5809, 0x03},
    {0x580a, 0x05},
    {0x580b, 0x06},
    {0x580c, 0x05},
    {0x580d, 0x02},
    {0x580e, 0x00},
    {0x580f, 0x00},
    {0x5810, 0x02},
    {0x5811, 0x05},
    {0x5812, 0x06},
    {0x5813, 0x02},
    {0x5814, 0x00},
    {0x5815, 0x00},
    {0x5816, 0x02},
    {0x5817, 0x05},
    {0x5818, 0x07},
    {0x5819, 0x05},
    {0x581a, 0x04},
    {0x581b, 0x03},
    {0x581c, 0x05},
    {0x581d, 0x06},
    {0x581e, 0x13},
    {0x581f, 0x0b},
    {0x5820, 0x09},
    {0x5821, 0x09},
    {0x5822, 0x0b},
    {0x5823, 0x16},
    {0x5824, 0x63},
    {0x5825, 0x23},
    {0x5826, 0x25},
    {0x5827, 0x23},
    {0x5828, 0x45},
    {0x5829, 0x23},
    {0x582a, 0x21},
    {0x582b, 0x41},
    {0x582c, 0x41},
    {0x582d, 0x05},
    {0x582e, 0x23},
    {0x582f, 0x41},
    {0x5830, 0x41},
    {0x5831, 0x41},
    {0x5832, 0x03},
    {0x5833, 0x25},
    {0x5834, 0x23},
    {0x5835, 0x21},
    {0x5836, 0x23},
    {0x5837, 0x05},
    {0x5838, 0x25},
    {0x5839, 0x43},
    {0x583a, 0x25},
    {0x583b, 0x23},
    {0x583c, 0x65},
    {0x583d, 0xcf},
    {0x5842, 0x00},
    {0x5843, 0xef},
    {0x5844, 0x01},
    {0x5845, 0x3f},
    {0x5846, 0x01},
    {0x5847, 0x3f},
    {0x5848, 0x00},
    {0x5849, 0xd5},
    {0x0100, 0x01}, //0x0100[0]=1 as start streaming

    {OV8820_TABLE_END, 0x0000}
};

static struct ov8820_reg mode_start[] = {
	{0x0100, 0x00}, /* software standby */
    {0x3000, 0x02},
    {0x3001, 0x00},
    {0x3002, 0x6c},
    {0x3003, 0xce},
    {0x3004, 0xd9},
    {0x3005, 0x00},
    {0x3006, 0x10},
    {0x3007, 0x3b},
    {0x300d, 0x00},
    {0x301f, 0x09},
    {0x3010, 0x00},
    {0x3011, 0x01},
    {0x3012, 0x80},
    {0x3013, 0x39},
    {0x3018, 0x00},
    {0x3104, 0x20},
    {0x3300, 0x00},
    {0x3500, 0x00},
    {0x3501, 0x4e},
    {0x3502, 0xa0},
    {0x3503, 0x07},
    {0x3509, 0x00},
    {0x350b, 0x1f},
    {0x3600, 0x05},
    {0x3601, 0x32},
    {0x3602, 0x44},
    {0x3603, 0x5c},
    {0x3604, 0x98},
    {0x3605, 0xe9},
    {0x3609, 0xb8},
    {0x360a, 0xbc},
    {0x360b, 0xb4},
    {0x360c, 0x0d},
    {0x3613, 0x02},
    {0x3614, 0x0f},
    {0x3615, 0x00},
    {0x3616, 0x03},
    {0x3617, 0x01},
    {0x361a, 0xb0},
    {0x361b, 0x04},
    {0x361c, 0x06},
    {0x3700, 0x20},
    {0x3701, 0x44},
    {0x3702, 0x70},
    {0x3703, 0x4f},
    {0x3704, 0x69},
    {0x3706, 0x7b},
    {0x3707, 0x63},
    {0x3708, 0x85},
    {0x3709, 0x40},
    {0x370a, 0x12},
    {0x370b, 0x01},
    {0x370c, 0x50},
    {0x370d, 0x0c},
    {0x370e, 0x08},
    {0x3711, 0x01},
    {0x3712, 0xcc},
    {0x3800, 0x00},
    {0x3801, 0x00},
    {0x3802, 0x00},
    {0x3803, 0x00},
    {0x3804, 0x0c},
    {0x3805, 0xdf},
    {0x3806, 0x09},
    {0x3807, 0x9b},
    {0x3808, 0x06},
    {0x3809, 0x60},
    {0x380a, 0x04},
    {0x380b, 0xc8},
    {0x380c, 0x0d},
    {0x380d, 0xbc},
    {0x380e, 0x04},
    {0x380f, 0xf0},
    {0x3810, 0x00},
    {0x3811, 0x08},
    {0x3812, 0x00},
    {0x3813, 0x04},
    {0x3814, 0x31},
    {0x3815, 0x31},
    {0x3816, 0x02},
    {0x3817, 0x40},
    {0x3818, 0x00},
    {0x3819, 0x40},
    {0x3820, 0x00},
    {0x3821, 0x17},
    {0x3d00, 0x00},
    {0x3d01, 0x00},
    {0x3d02, 0x00},
    {0x3d03, 0x00},
    {0x3d04, 0x00},
    {0x3d05, 0x00},
    {0x3d06, 0x00},
    {0x3d07, 0x00},
    {0x3d08, 0x00},
    {0x3d09, 0x00},
    {0x3d0a, 0x00},
    {0x3d0b, 0x00},
    {0x3d0c, 0x00},
    {0x3d0d, 0x00},
    {0x3d0e, 0x00},
    {0x3d0f, 0x00},
    {0x3d10, 0x00},
    {0x3d11, 0x00},
    {0x3d12, 0x00},
    {0x3d13, 0x00},
    {0x3d14, 0x00},
    {0x3d15, 0x00},
    {0x3d16, 0x00},
    {0x3d17, 0x00},
    {0x3d18, 0x00},
    {0x3d19, 0x00},
    {0x3d1a, 0x00},
    {0x3d1b, 0x00},
    {0x3d1c, 0x00},
    {0x3d1d, 0x00},
    {0x3d1e, 0x00},
    {0x3d1f, 0x00},
    {0x3d80, 0x00},
    {0x3d81, 0x00},
    {0x3d84, 0x00},
    {0x3f00, 0x00},
    {0x3f01, 0xfc},
    {0x3f05, 0x10},
    {0x3f06, 0x00},
    {0x3f07, 0x00},
    {0x4000, 0x29},
    {0x4001, 0x02},
    {0x4002, 0x45},
    {0x4003, 0x08},
    {0x4004, 0x04},
    {0x4005, 0x18},
    {0x4300, 0xff},
    {0x4303, 0x00},
    {0x4304, 0x08},
    {0x4307, 0x00},
    {0x4600, 0x04},
    {0x4601, 0x00},
    {0x4602, 0x78},
    {0x4800, 0x04},
    {0x4801, 0x0f},
    {0x4837, 0x28},
    {0x4843, 0x02},
    {0x5000, 0x86},//Enable defect pixel correction
    {0x5001, 0x00},
    {0x5002, 0x00},
    {0x5068, 0x00},
    {0x506a, 0x00},
    {0x501f, 0x00},
    {0x5c00, 0x80},
    {0x5c01, 0x00},
    {0x5c02, 0x00},
    {0x5c03, 0x00},
    {0x5c04, 0x00},
    {0x5c05, 0x00},
    {0x5c06, 0x00},
    {0x5c07, 0x80},
    {0x5c08, 0x10},
    {0x6700, 0x05},
    {0x6701, 0x19},
    {0x6702, 0xfd},
    {0x6703, 0xd1},
    {0x6704, 0xff},
    {0x6705, 0xff},
    {0x6800, 0x10},
    {0x6801, 0x02},
    {0x6802, 0x90},
    {0x6803, 0x10},
    {0x6804, 0x59},
    {0x6900, 0x61},
    {0x6901, 0x05},
    {0x3612, 0x00},
    {0x3617, 0xa1},
    {0x3b1f, 0x00},
    {0x3000, 0x12},
    {0x3000, 0x16},
    {0x3b1f, 0x00},
    {0x5800, 0x16},
    {0x5801, 0x0b},
    {0x5802, 0x09},
    {0x5803, 0x09},
    {0x5804, 0x0b},
    {0x5805, 0x15},
    {0x5806, 0x07},
    {0x5807, 0x05},
    {0x5808, 0x03},
    {0x5809, 0x03},
    {0x580a, 0x05},
    {0x580b, 0x06},
    {0x580c, 0x05},
    {0x580d, 0x02},
    {0x580e, 0x00},
    {0x580f, 0x00},
    {0x5810, 0x02},
    {0x5811, 0x05},
    {0x5812, 0x06},
    {0x5813, 0x02},
    {0x5814, 0x00},
    {0x5815, 0x00},
    {0x5816, 0x02},
    {0x5817, 0x05},
    {0x5818, 0x07},
    {0x5819, 0x05},
    {0x581a, 0x04},
    {0x581b, 0x03},
    {0x581c, 0x05},
    {0x581d, 0x06},
    {0x581e, 0x13},
    {0x581f, 0x0b},
    {0x5820, 0x09},
    {0x5821, 0x09},
    {0x5822, 0x0b},
    {0x5823, 0x16},
    {0x5824, 0x63},
    {0x5825, 0x23},
    {0x5826, 0x25},
    {0x5827, 0x23},
    {0x5828, 0x45},
    {0x5829, 0x23},
    {0x582a, 0x21},
    {0x582b, 0x41},
    {0x582c, 0x41},
    {0x582d, 0x05},
    {0x582e, 0x23},
    {0x582f, 0x41},
    {0x5830, 0x41},
    {0x5831, 0x41},
    {0x5832, 0x03},
    {0x5833, 0x25},
    {0x5834, 0x23},
    {0x5835, 0x21},
    {0x5836, 0x23},
    {0x5837, 0x05},
    {0x5838, 0x25},
    {0x5839, 0x43},
    {0x583a, 0x25},
    {0x583b, 0x23},
    {0x583c, 0x65},
    {0x583d, 0xcf},
    {0x5842, 0x00},
    {0x5843, 0xef},
    {0x5844, 0x01},
    {0x5845, 0x3f},
    {0x5846, 0x01},
    {0x5847, 0x3f},
    {0x5848, 0x00},
    {0x5849, 0xd5},
//    {0x0100, 0x01},
	{OV8820_TABLE_END, 0x0},
};

static struct ov8820_reg mode_end[] = {
#if 0
	{0x3208, 0x00}, /* SRM_GROUP_ACCESS (group hold begin) */
	{0x3208, 0x10}, /* SRM_GROUP_ACCESS (group hold end) */
	{0x3208, 0xa0}, /* SRM_GROUP_ACCESS (group hold launch) */
#endif
	{OV8820_TABLE_END, 0x0000}
};

enum {
    OV8820_MODE_1632x1224,
    OV8820_MODE_3264x2448,
    OV8820_MODE_1920x1080,
	OV8820_MODE_INVALID
};

static struct ov8820_reg *mode_table[] = {
    [OV8820_MODE_1632x1224] = mode_1632x1224,
    [OV8820_MODE_3264x2448] = mode_3264x2448,
    [OV8820_MODE_1920x1080] = mode_1920x1080,
};

/* 2 regs to program frame length */
static inline void ov8820_get_frame_length_regs(struct ov8820_reg *regs,
						u32 frame_length)
{
	regs->addr = 0x380e;
	regs->val = (frame_length >> 8) & 0xff;
	(regs + 1)->addr = 0x380f;
	(regs + 1)->val = (frame_length) & 0xff;
}

/* 3 regs to program coarse time */
static inline void ov8820_get_coarse_time_regs(struct ov8820_reg *regs,
						u32 coarse_time)
{
	regs->addr = 0x3500;
	regs->val = (coarse_time >> 12) & 0xff;
	(regs + 1)->addr = 0x3501;
	(regs + 1)->val = (coarse_time >> 4) & 0xff;
	(regs + 2)->addr = 0x3502;
	(regs + 2)->val = (coarse_time & 0xf) << 4;
}

/* 2 reg to program gain */
static inline void ov8820_get_gain_reg(struct ov8820_reg *regs, u16 gain)
{
	regs->addr = 0x350a;
	regs->val = (gain >> 8) & 0x07;
	(regs + 1)->addr = 0x350b;
	(regs + 1)->val = (gain) & 0xff;
}

static int ov8820_write_reg(struct i2c_client *client, u16 addr, u8 val)
{
#if 0
	int err;
	struct i2c_msg msg;
	unsigned char data[3];
	int retry = 0;

	if (!client->adapter)
		return -ENODEV;

	data[0] = (u8) (addr >> 8);;
	data[1] = (u8) (addr & 0xff);
	data[2] = (u8) (val & 0xff);

	msg.addr = client->addr;
	msg.flags = 0;
	msg.len = 3;
	msg.buf = data;

	do {
		err = i2c_transfer(client->adapter, &msg, 1);
		if (err == 1)
			return 0;
		retry++;
		pr_err("ov8820: i2c transfer failed, retrying %x %x\n",
			addr, val);
		usleep_range(3000, 3250);
	} while (retry <= OV8820_MAX_RETRIES);

	return err;
#endif
    return ov8820_i2c_write_reg(client, addr, val);
}

static int ov8820_write_table(struct i2c_client *client,
				const struct ov8820_reg table[],
				const struct ov8820_reg override_list[],
				int num_override_regs)
{
	int err;
	const struct ov8820_reg *next;
	int i;
	u16 val;

	for (next = table; next->addr != OV8820_TABLE_END; next++) {
		if (next->addr == OV8820_TABLE_WAIT_MS) {
			msleep(next->val);
			continue;
		}

		val = next->val;

		/* When an override list is passed in, replace the reg */
		/* value to write if the reg is in the list            */
		if (override_list) {
			for (i = 0; i < num_override_regs; i++) {
				if (next->addr == override_list[i].addr) {
					val = override_list[i].val;
					break;
				}
			}
		}

		err = ov8820_write_reg(client, next->addr, val);
		if (err)
			return err;
	}
	return 0;
}

static int ov8820_set_mode(struct ov8820_info *info, struct ov8820_mode *mode)
{
	int sensor_mode;
	int err;
	struct ov8820_reg reg_list[7];

	pr_debug(KERN_DEBUG "%s: xres %u yres %u framelength %u coarsetime %u gain %u\n",
		__func__, mode->xres, mode->yres, mode->frame_length,
		mode->coarse_time, mode->gain);
    s16 position;
    u8 pos1, pos2;
    int nerr = 0;
    nerr = ov8820_i2c_read_reg(NULL, 0x3618, &pos1);
    nerr |= ov8820_i2c_read_reg(NULL, 0x3619, &pos2);
    if(!nerr) {
        position = ((pos2 & 0x3F) << 4) | ((pos1 & 0xF0) >> 4);
    } else {
		return nerr;
    }
	//if (mode->xres == 3264 && mode->yres == 2448)
	if (mode->xres == 3248 && mode->yres == 2432)
		sensor_mode = OV8820_MODE_3264x2448;
	else if (mode->xres == 1632 && mode->yres == 1224)
		sensor_mode = OV8820_MODE_1632x1224;
	else if (mode->xres == 1920 && mode->yres == 1080)
		sensor_mode = OV8820_MODE_1920x1080;
	else {
		pr_err("%s: invalid resolution supplied to set mode %d %d\n",
		       __func__, mode->xres, mode->yres);
		return -EINVAL;
	}

	/* get a list of override regs for the asking frame length, */
	/* coarse integration time, and gain.                       */
	ov8820_get_frame_length_regs(reg_list, mode->frame_length);
	ov8820_get_coarse_time_regs(reg_list + 2, mode->coarse_time);
	ov8820_get_gain_reg(reg_list + 5, mode->gain);

	err = ov8820_write_table(info->i2c_client, mode_start, NULL, 0);
	if (err)
		return err;


	err = ov8820_write_table(info->i2c_client, mode_table[sensor_mode],
		reg_list, 7);
	if (err)
		return err;

	err = ov8820_write_table(info->i2c_client, mode_end, NULL, 0);
	if (err)
		return err;


	info->mode = sensor_mode;

	return 0;
}

static int ov8820_set_frame_length(struct ov8820_info *info, u32 frame_length)
{
	struct ov8820_reg reg_list[2];
	int i = 0;
	int ret;

	ov8820_get_frame_length_regs(reg_list, frame_length);

	for (i = 0; i < 2; i++)	{
		ret = ov8820_write_reg(info->i2c_client, reg_list[i].addr,
			reg_list[i].val);
		if (ret)
			return ret;
	}

	return 0;
}

static int ov8820_set_coarse_time(struct ov8820_info *info, u32 coarse_time)
{
	int ret = 0;

	struct ov8820_reg reg_list[3];
	int i = 0;

	ov8820_get_coarse_time_regs(reg_list, coarse_time);

	//ret = ov8820_write_reg(info->i2c_client, 0x3208, 0x01);
	if (ret)
		return ret;

	for (i = 0; i < 3; i++)	{
		ret = ov8820_write_reg(info->i2c_client, reg_list[i].addr,
			reg_list[i].val);
		if (ret)
			return ret;
	}

	//ret = ov8820_write_reg(info->i2c_client, 0x3208, 0x11);
	if (ret)
		return ret;

	//ret = ov8820_write_reg(info->i2c_client, 0x3208, 0xa1);
	if (ret)
		return ret;

	return 0;
}

static int ov8820_set_gain(struct ov8820_info *info, u16 gain)
{
	int ret;
	struct ov8820_reg reg_list[2];
	int i = 0;


	ov8820_get_gain_reg(reg_list, gain);

	for (i = 0; i < 2; i++)	{
		ret = ov8820_write_reg(info->i2c_client, reg_list[i].addr,
			reg_list[i].val);
		if (ret)
			return ret;
	}

	return ret;
}

static int ov8820_test_pattern(struct ov8820_info *info,
			       enum ov8820_test_pattern pattern)
{
	if (pattern >= ARRAY_SIZE(test_pattern_modes))
		return -EINVAL;

	return ov8820_write_table(info->i2c_client,
				  test_pattern_modes[pattern],
				  NULL, 0);
}

static int ov8820_set_group_hold(struct ov8820_info *info, struct tegra_camera_ae *ae)
{
	int ret;
	int count = 0;
	bool groupHoldEnabled = false;

    pr_debug(KERN_DEBUG "%s %d\n", __func__, __LINE__);

	if (ae->gain_enable)
		count++;
	if (ae->coarse_time_enable)
		count++;
	if (ae->frame_length_enable)
		count++;
	if (count >= 2)
		groupHoldEnabled = true;

	if (groupHoldEnabled) {
		ret = ov8820_write_reg(info, 0x3208, 0x00);
		if (ret)
			return ret;
	}

	if (ae->gain_enable)
		ov8820_set_gain(info, ae->gain);
	if (ae->coarse_time_enable)
		ov8820_set_coarse_time(info, ae->coarse_time);
	if (ae->frame_length_enable)
		ov8820_set_frame_length(info, ae->frame_length);

	if (groupHoldEnabled) {
		ret = ov8820_write_reg(info, 0x3208, 0x10);
		if (ret)
			return ret;


		ret = ov8820_write_reg(info, 0x3208, 0xa0);
		if (ret)
			return ret;
	}

	return 0;
}



static long ov8820_ioctl(struct file *file,
			 unsigned int cmd, unsigned long arg)
{
	switch (cmd) {
	case OV8820_IOCTL_SET_MODE:
	{
		struct ov8820_mode mode;
		if (copy_from_user(&mode,
				   (const void __user *)arg,
				   sizeof(struct ov8820_mode))) {
			pr_debug(KERN_DEBUG "%s %d\n", __func__, __LINE__);
			return -EFAULT;
		}

		return ov8820_set_mode(info, &mode);
	}
	case OV8820_IOCTL_SET_FRAME_LENGTH:
		return ov8820_set_frame_length(info, (u32)arg);
	case OV8820_IOCTL_SET_COARSE_TIME:
		return ov8820_set_coarse_time(info, (u32)arg);
	case OV8820_IOCTL_SET_GAIN:
		return ov8820_set_gain(info, (u16)arg);
	case OV8820_IOCTL_GET_STATUS:
	{
		u16 status = 0;
		if (copy_to_user((void __user *)arg, &status,
				 2)) {
			pr_debug(KERN_DEBUG "%s %d\n", __func__, __LINE__);
			return -EFAULT;
		}
		return 0;
	}
	case OV8820_IOCTL_GET_SENSOR_ID:
	{
		if (FuseIDReadOnce == 0)
		{
			int err = 0;

            ov8820_write_reg(NULL, 0x0103, 0x01);
            msleep(5);
            ov8820_write_reg(NULL, 0x0103, 0x00);
            msleep(5);
            ov8820_write_reg(NULL, 0x0100, 0x01);
            msleep(5);

			err |= ov8820_write_reg(NULL, OV8820_OTP_BANK_SELECT, OV8820_OTP_BANK_EN_BIT);
			err |= ov8820_write_reg(NULL, OV8820_OTP_READ_NWRITE, OV8820_OTP_READ_BIT);
			msleep(1);
			// read the 5-byte fuse id
			err |= ov8820_i2c_read_reg(NULL, OV8820_FUSEID_REG0, &FuseID[0]);
			err |= ov8820_i2c_read_reg(NULL, OV8820_FUSEID_REG1, &FuseID[1]);
			err |= ov8820_i2c_read_reg(NULL, OV8820_FUSEID_REG2, &FuseID[2]);
			err |= ov8820_i2c_read_reg(NULL, OV8820_FUSEID_REG3, &FuseID[3]);
			err |= ov8820_i2c_read_reg(NULL, OV8820_FUSEID_REG4, &FuseID[4]);

			if (err) {
				pr_err("%s GET_SENSOR_ID %d %d\n", __func__, __LINE__, err);
				return err;
			}
			pr_debug(KERN_DEBUG "ov8820 %s FuseID: %X %X %X %X %X\n", __func__,
				FuseID[0], FuseID[1], FuseID[2], FuseID[3], FuseID[4]);
			FuseIDReadOnce = 1;
		}
		if (copy_to_user((void __user *)arg, FuseID,
				 5)) {
			pr_debug(KERN_DEBUG "[CAM] %s %d\n", __func__, __LINE__);
			return -EFAULT;
		}
		return 0;
	}
	case OV8820_IOCTL_TEST_PATTERN:
	{
        int err;
		err = ov8820_test_pattern(info, (enum ov8820_test_pattern) arg);
		if (err)
			pr_err("%s %d %d\n", __func__, __LINE__, err);
		return err;
	}

	case OV8820_IOCTL_SET_GROUP_HOLD:
	{
		struct tegra_camera_ae ae;
		if (copy_from_user(&ae,
				(const void __user *)arg,
				sizeof(struct tegra_camera_ae))) {
			pr_debug(KERN_DEBUG "%s %d\n", __func__, __LINE__);
			return -EFAULT;
		}
		return ov8820_set_group_hold(info, &ae);
	}


	default:
		return -EINVAL;
	}
	return 0;
}

static int ov8820_open(struct inode *inode, struct file *file)
{
    int err;

	pr_debug(KERN_DEBUG "%s\n", __func__);
	file->private_data = info;
	err = ov8820_write_table(info->i2c_client, reset_seq, NULL, 0);
	if (err)
		return err;

	return 0;
}

int ov8820_release(struct inode *inode, struct file *file)
{
	pr_debug(KERN_DEBUG "%s\n", __func__);
	file->private_data = NULL;

	return 0;
}


static const struct file_operations ov8820_fileops = {
	.owner = THIS_MODULE,
	.open = ov8820_open,
	.unlocked_ioctl = ov8820_ioctl,
	.release = ov8820_release,
};

static struct miscdevice ov8820_device = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = "ov8820",
	.fops = &ov8820_fileops,
};

//static int ov8820_probe(struct i2c_client *client,
//            const struct i2c_device_id *id)
static int ov8820_probe(struct platform_device *client,
            const struct platform_device_id *id)
{
	int err;
	pr_debug(KERN_DEBUG "%s: probing sensor.\n", __func__);

	info = kzalloc(sizeof(struct ov8820_info), GFP_KERNEL);
	if (!info) {
		pr_err("ov8820: Unable to allocate memory!\n");
		return -ENOMEM;
	}

	err = misc_register(&ov8820_device);
	if (err) {
		pr_err("ov8820: Unable to register misc device!\n");
		kfree(info);
		return err;
	}

	return 0;
}

static int ov8820_remove(struct i2c_client *client)
{
	pr_debug(KERN_DEBUG "%s\n", __func__);
	struct ov8820_info *info;
	misc_deregister(&ov8820_device);
	kfree(info);
	return 0;
}

static const struct i2c_device_id ov8820_id[] = {
	{ "ov8820", 0 },
	{ },
};

//MODULE_DEVICE_TABLE(i2c, ov8820_id);
MODULE_DEVICE_TABLE(platform, ov8820_id);

//static struct i2c_driver ov8820_i2c_driver = {
static struct platform_driver ov8820_driver = {
	.driver = {
		.name = "ov8820",
		.owner = THIS_MODULE,
	},
	.probe = ov8820_probe,
	.remove = ov8820_remove,
	.id_table = ov8820_id,
};

static int __init ov8820_init(void)
{
	pr_debug(KERN_DEBUG "%s sensor driver loading\n", __func__);
	return platform_driver_register(&ov8820_driver);
}

static void __exit ov8820_exit(void)
{
	pr_debug(KERN_DEBUG "%s sensor driver exiting\n", __func__);
	FuseIDReadOnce = 0;
	return platform_driver_unregister(&ov8820_driver);
}

module_init(ov8820_init);
module_exit(ov8820_exit);

